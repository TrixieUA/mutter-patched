From fc891a697d198a8e65893b7c1bb9535b6d362116 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 29 Mar 2023 12:41:54 +0200
Subject: [PATCH 01/19] frame: Use uint8_t instead of guchar when setting
 property

---
 src/core/frame.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index 3d6e7ab78b..09d08a208f 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -52,7 +52,7 @@ meta_window_ensure_frame (MetaWindow *window)
                    window->xwindow,
                    x11_display->atom__MUTTER_NEEDS_FRAME,
                    XA_CARDINAL,
-                   32, PropModeReplace, (guchar*) data, 1);
+                   32, PropModeReplace, (uint8_t *) data, 1);
 
   meta_x11_error_trap_pop (x11_display);
 }
-- 
GitLab


From 4c62a9e2e765e742f1656bd82db8eb2f6fd9c525 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Apr 2023 14:27:24 +0200
Subject: [PATCH 02/19] stack-tracker: Clean up sync_stack() code

Refer to stack IDs as `stack_id`, and X11 `Window`s as `xwindow`, and
`MetaWindow` as `window`. While at it, use a auto-ptr for the transient
list.
---
 src/core/stack-tracker.c | 40 +++++++++++++++++++++++-----------------
 1 file changed, 23 insertions(+), 17 deletions(-)

diff --git a/src/core/stack-tracker.c b/src/core/stack-tracker.c
index bc109381b3..695ae2f9cf 100644
--- a/src/core/stack-tracker.c
+++ b/src/core/stack-tracker.c
@@ -1009,8 +1009,8 @@ meta_stack_tracker_get_stack (MetaStackTracker *tracker,
 void
 meta_stack_tracker_sync_stack (MetaStackTracker *tracker)
 {
-  guint64 *windows;
-  GList *meta_windows;
+  uint64_t *stack_ids;
+  g_autoptr (GList) windows = NULL;
   int n_windows;
   int i;
 
@@ -1025,20 +1025,20 @@ meta_stack_tracker_sync_stack (MetaStackTracker *tracker)
 
   meta_stack_tracker_keep_override_redirect_on_top (tracker);
 
-  meta_stack_tracker_get_stack (tracker, &windows, &n_windows);
+  meta_stack_tracker_get_stack (tracker, &stack_ids, &n_windows);
 
-  meta_windows = NULL;
   for (i = 0; i < n_windows; i++)
     {
-      guint64 window = windows[i];
+      uint64_t stack_id = stack_ids[i];
 
-      if (META_STACK_ID_IS_X11 (window))
+      if (META_STACK_ID_IS_X11 (stack_id))
         {
           MetaX11Display *x11_display = tracker->display->x11_display;
-          MetaWindow *meta_window = NULL;
+          Window xwindow = (Window) stack_id;
+          MetaWindow *window = NULL;
 
           if (x11_display)
-            meta_window = meta_x11_display_lookup_x_window (x11_display, (Window) window);
+            window = meta_x11_display_lookup_x_window (x11_display, xwindow);
 
           /* When mapping back from xwindow to MetaWindow we have to be a bit careful;
            * children of the root could include unmapped windows created by toolkits
@@ -1046,19 +1046,25 @@ meta_stack_tracker_sync_stack (MetaStackTracker *tracker)
            * XID => window table. (Wine uses a toplevel for _NET_WM_USER_TIME_WINDOW;
            * see window-prop.c:reload_net_wm_user_time_window() for registration.)
            */
-          if (meta_window &&
-              ((Window)window == meta_window->xwindow ||
-               (meta_window->frame && (Window)window == meta_window->frame->xwindow)))
-            meta_windows = g_list_prepend (meta_windows, meta_window);
+          if (window)
+            {
+              if (window->frame &&
+                  window->frame->xwindow == xwindow)
+                windows = g_list_prepend (windows, window);
+              else if (xwindow == window->xwindow)
+                windows = g_list_prepend (windows, window);
+            }
         }
       else
-        meta_windows = g_list_prepend (meta_windows,
-                                       meta_display_lookup_stamp (tracker->display, window));
+        {
+          MetaWindow *window;
+
+          window = meta_display_lookup_stamp (tracker->display, stack_id);
+          windows = g_list_prepend (windows, window);
+        }
     }
 
-  meta_compositor_sync_stack (tracker->display->compositor,
-                              meta_windows);
-  g_list_free (meta_windows);
+  meta_compositor_sync_stack (tracker->display->compositor, windows);
 
   meta_display_restacked (tracker->display);
 }
-- 
GitLab


From d3dad76f6bcf5b89e35ead0b550b36ac678dc5cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Apr 2023 14:31:18 +0200
Subject: [PATCH 03/19] x11/stack: Don't remove frame xwindow

It was never added, so it's no point removing it.
---
 src/x11/meta-x11-stack.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/x11/meta-x11-stack.c b/src/x11/meta-x11-stack.c
index 95cefc1e59..08a798045b 100644
--- a/src/x11/meta-x11-stack.c
+++ b/src/x11/meta-x11-stack.c
@@ -130,11 +130,6 @@ stack_window_removed_cb (MetaStack    *stack,
 
   x11_stack->removed = g_list_prepend (x11_stack->removed,
                                    GUINT_TO_POINTER (window->xwindow));
-  if (window->frame)
-    {
-      x11_stack->removed = g_list_prepend (x11_stack->removed,
-                                           GUINT_TO_POINTER (window->frame->xwindow));
-    }
 }
 
 /**
-- 
GitLab


From 84fd45eb5f48704f36c1c891b134534a5b461ea1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Apr 2023 14:32:13 +0200
Subject: [PATCH 04/19] x11/stack: Fix indentation

---
 src/x11/meta-x11-stack.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/x11/meta-x11-stack.c b/src/x11/meta-x11-stack.c
index 08a798045b..38d54c0f58 100644
--- a/src/x11/meta-x11-stack.c
+++ b/src/x11/meta-x11-stack.c
@@ -129,7 +129,7 @@ stack_window_removed_cb (MetaStack    *stack,
   x11_stack->added = g_list_remove (x11_stack->added, window);
 
   x11_stack->removed = g_list_prepend (x11_stack->removed,
-                                   GUINT_TO_POINTER (window->xwindow));
+                                       GUINT_TO_POINTER (window->xwindow));
 }
 
 /**
-- 
GitLab


From 7e85dbee53c1ef1629d77da6c2e8734499c46583 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 29 Mar 2023 13:16:24 +0200
Subject: [PATCH 05/19] x11/events: Only fetch timestamp when needed

Also remove a 'wishful-thinking' comment about X11 changing.
---
 src/x11/events.c | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/src/x11/events.c b/src/x11/events.c
index 4481941256..c2cebf72b1 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -1411,13 +1411,6 @@ handle_other_xevent (MetaX11Display *x11_display,
       }
       if (window)
         {
-          /* FIXME: It sucks that DestroyNotify events don't come with
-           * a timestamp; could we do something better here?  Maybe X
-           * will change one day?
-           */
-          guint32 timestamp;
-          timestamp = meta_display_get_current_time_roundtrip (display);
-
           if (frame_was_receiver)
             {
               meta_x11_error_trap_push (x11_display);
@@ -1426,7 +1419,9 @@ handle_other_xevent (MetaX11Display *x11_display,
             }
           else
             {
-              /* Unmanage destroyed window */
+              uint32_t timestamp;
+
+              timestamp = meta_display_get_current_time_roundtrip (display);
               meta_window_unmanage (window, timestamp);
               window = NULL;
             }
-- 
GitLab


From 90de5ab1523a60440f840bd9c8d38dca9c74d3a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 4 Apr 2023 10:31:47 +0200
Subject: [PATCH 06/19] x11/display: XSync() before terminating frames client

If we don't, we aren't guaranteed we have unparented client window
before the frames client destroys the frame window. This avoids a race
where client windows would receive DestroyNotify events for their
windows when mutter restarts.
---
 src/x11/meta-x11-display.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 16cab06d82..3b8fc78e0b 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -163,6 +163,8 @@ meta_x11_display_dispose (GObject *object)
 
   if (x11_display->frames_client)
     {
+      XSync (x11_display->xdisplay, False);
+
       g_subprocess_send_signal (x11_display->frames_client, SIGTERM);
       if (x11_display->display->closing)
         g_subprocess_wait (x11_display->frames_client, NULL, NULL);
-- 
GitLab


From d56086c83e64bc3c40bff8bce968fb94edbcbf94 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 29 Mar 2023 13:20:34 +0200
Subject: [PATCH 07/19] x11/frame: Always wrap client window in a wrapper
 window

The wrapper window aims to result in no extra blits in the X server by
using an identical visual and size as the parent window, and should
effectively not be visible ignoring the racyness of X11 window resizes.

The aim for this is to later re-introduce unparenting a window from the
frame window to avoid extra blits when fullscreen. Unparenting the
client window themselves triggers unfixable bugs in old X11 clients that
never expect to change, but unparenting the wrapper instead avoids these
issues.
---
 src/core/frame.c       | 96 +++++++++++++++++++++++++++++++++++++++---
 src/core/frame.h       |  8 +++-
 src/core/window.c      |  7 +--
 src/x11/events.c       | 28 +++++++-----
 src/x11/window-props.c |  5 +--
 src/x11/window-x11.c   | 26 +++++++++---
 6 files changed, 136 insertions(+), 34 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index 09d08a208f..4160189d44 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -40,8 +40,8 @@
                     StructureNotifyMask | SubstructureNotifyMask | \
                     PropertyChangeMask | FocusChangeMask)
 
-void
-meta_window_ensure_frame (MetaWindow *window)
+static void
+request_frame (MetaWindow *window)
 {
   MetaX11Display *x11_display = window->display->x11_display;
   unsigned long data[1] = { 1 };
@@ -57,6 +57,65 @@ meta_window_ensure_frame (MetaWindow *window)
   meta_x11_error_trap_pop (x11_display);
 }
 
+void
+meta_window_sync_frame_state (MetaWindow *window)
+{
+  if (window->client_type != META_WINDOW_CLIENT_TYPE_X11)
+    return;
+
+  if (!window->decorated)
+    meta_window_destroy_frame (window);
+  else if (!window->frame)
+    request_frame (window);
+}
+
+static void
+init_wrapper_window (MetaFrame *frame)
+{
+  MetaWindow *window = frame->window;
+  MetaX11Display *x11_display = window->display->x11_display;
+  XSetWindowAttributes xattr = {};
+  long mask;
+
+  xattr.background_pixel = BlackPixel (x11_display->xdisplay,
+                                       DefaultScreen (x11_display->xdisplay));
+  xattr.border_pixel = xattr.background_pixel;
+  xattr.event_mask = StructureNotifyMask | PropertyChangeMask;
+  xattr.bit_gravity = NorthWestGravity;
+  xattr.colormap =
+    XCreateColormap (x11_display->xdisplay,
+                     x11_display->xroot,
+                     window->xvisual,
+                     AllocNone);
+
+  mask = (CWBorderPixel | CWColormap | CWEventMask | CWBitGravity |
+          SubstructureNotifyMask);
+
+  frame->wrapper_xwindow = XCreateWindow (x11_display->xdisplay,
+                                          frame->xwindow,
+                                          0, 0,
+                                          window->rect.width,
+                                          window->rect.height,
+                                          0,
+                                          window->depth,
+                                          InputOutput,
+                                          window->xvisual,
+                                          mask, &xattr);
+  XSelectInput (x11_display->xdisplay,
+                frame->wrapper_xwindow,
+                StructureNotifyMask | SubstructureNotifyMask);
+
+  XReparentWindow (x11_display->xdisplay,
+                   window->xwindow,
+                   frame->wrapper_xwindow,
+                   0, 0);
+  XMapWindow (x11_display->xdisplay, frame->wrapper_xwindow);
+  window->reparents_pending += 1;
+
+  meta_x11_display_register_x_window (x11_display,
+                                      &frame->wrapper_xwindow, window);
+}
+
 void
 meta_window_set_frame_xwindow (MetaWindow *window,
                                Window      xframe)
@@ -123,15 +182,17 @@ meta_window_set_frame_xwindow (MetaWindow *window,
       window->unmaps_pending += 1;
     }
 
+  init_wrapper_window (frame);
+
   meta_stack_tracker_record_remove (window->display->stack_tracker,
                                     window->xwindow,
                                     XNextRequest (x11_display->xdisplay));
   XReparentWindow (x11_display->xdisplay,
-                   window->xwindow,
+                   frame->wrapper_xwindow,
                    frame->xwindow,
                    frame->child_x,
                    frame->child_y);
-  window->reparents_pending += 1;
+
   /* FIXME handle this error */
   meta_x11_error_trap_pop (x11_display);
 
@@ -226,6 +287,16 @@ meta_window_destroy_frame (MetaWindow *window)
                    window->xwindow,
                    x11_display->atom__MUTTER_NEEDS_FRAME);
 
+  if (frame->wrapper_xwindow != None)
+    {
+      XDestroyWindow (window->display->x11_display->xdisplay,
+                      frame->wrapper_xwindow);
+
+      meta_x11_display_unregister_x_window (x11_display,
+                                            frame->wrapper_xwindow);
+      frame->wrapper_xwindow = None;
+    }
+
   meta_x11_error_trap_pop (x11_display);
 
   /* Ensure focus is restored after the unmap/map events triggered
@@ -371,20 +442,33 @@ meta_frame_clear_cached_borders (MetaFrame *frame)
 
 gboolean
 meta_frame_sync_to_window (MetaFrame *frame,
+                           int        client_width,
+                           int        client_height,
                            gboolean   need_resize)
 {
   MetaWindow *window = frame->window;
   MetaX11Display *x11_display = window->display->x11_display;
+  MetaFrameBorders borders;
+
+  meta_frame_calc_borders (window->frame, &borders);
 
   meta_topic (META_DEBUG_GEOMETRY,
-              "Syncing frame geometry %d,%d %dx%d (SE: %d,%d)",
+              "Syncing frame geometry %d,%d %dx%d (SE: %d,%d), "
+              "wrapper: %d,%d %dx%d",
               frame->rect.x, frame->rect.y,
               frame->rect.width, frame->rect.height,
               frame->rect.x + frame->rect.width,
-              frame->rect.y + frame->rect.height);
+              frame->rect.y + frame->rect.height,
+              borders.total.left, borders.total.top,
+              client_width, client_height);
 
   meta_x11_error_trap_push (x11_display);
 
+  XMoveResizeWindow (window->display->x11_display->xdisplay,
+                     frame->wrapper_xwindow,
+                     borders.total.left, borders.total.top,
+                     client_width, client_height);
+
   XMoveResizeWindow (x11_display->xdisplay,
                      frame->xwindow,
                      frame->rect.x,
diff --git a/src/core/frame.h b/src/core/frame.h
index c134433ad6..90ad1f699c 100644
--- a/src/core/frame.h
+++ b/src/core/frame.h
@@ -30,8 +30,10 @@ struct _MetaFrame
   /* window we frame */
   MetaWindow *window;
 
-  /* reparent window */
+  /* Frame window */
   Window xwindow;
+  /* Wrapper window. */
+  Window wrapper_xwindow;
 
   /* This rect is trusted info from where we put the
    * frame, not the result of ConfigureNotify
@@ -53,7 +55,7 @@ struct _MetaFrame
   guint borders_cached : 1;
 };
 
-void     meta_window_ensure_frame           (MetaWindow *window);
+void     meta_window_sync_frame_state       (MetaWindow *window);
 void     meta_window_destroy_frame          (MetaWindow *window);
 
 Window         meta_frame_get_xwindow (MetaFrame *frame);
@@ -63,6 +65,8 @@ void meta_frame_calc_borders      (MetaFrame        *frame,
                                    MetaFrameBorders *borders);
 
 gboolean meta_frame_sync_to_window (MetaFrame         *frame,
+                                    int                client_width,
+                                    int                client_height,
                                     gboolean           need_resize);
 
 void meta_frame_clear_cached_borders (MetaFrame *frame);
diff --git a/src/core/window.c b/src/core/window.c
index 87bb0a6fa6..4329f9b958 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -5437,11 +5437,7 @@ meta_window_type_changed (MetaWindow *window)
   if (!window->override_redirect)
     set_net_wm_state (window);
 
-  /* Update frame */
-  if (window->decorated)
-    meta_window_ensure_frame (window);
-  else
-    meta_window_destroy_frame (window);
+  meta_window_sync_frame_state (window);
 
   /* update stacking constraints */
   meta_window_update_layer (window);
@@ -5712,6 +5708,7 @@ meta_window_recalc_features (MetaWindow *window)
   if (window->has_resize_func != old_has_resize_func)
     g_object_notify_by_pspec (G_OBJECT (window), obj_props[PROP_RESIZEABLE]);
 
+  meta_window_sync_frame_state (window);
   meta_window_frame_size_changed (window);
 }
 
diff --git a/src/x11/events.c b/src/x11/events.c
index c2cebf72b1..5074972352 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -1309,12 +1309,16 @@ handle_other_xevent (MetaX11Display *x11_display,
   MetaWorkspaceManager *workspace_manager = display->workspace_manager;
   Window modified;
   MetaWindow *window;
+  MetaFrame *frame;
   MetaWindow *property_for_window;
   gboolean frame_was_receiver;
+  gboolean wrapper_was_receiver;
 
   modified = event_get_modified_window (x11_display, event);
   window = modified != None ? meta_x11_display_lookup_x_window (x11_display, modified) : NULL;
-  frame_was_receiver = (window && window->frame && modified == window->frame->xwindow);
+  frame = window ? window->frame : NULL;
+  frame_was_receiver = frame && modified == frame->xwindow;
+  wrapper_was_receiver = frame && modified == frame->wrapper_xwindow;
 
   /* We only want to respond to _NET_WM_USER_TIME property notify
    * events on _NET_WM_USER_TIME_WINDOW windows; in particular,
@@ -1411,11 +1415,15 @@ handle_other_xevent (MetaX11Display *x11_display,
       }
       if (window)
         {
-          if (frame_was_receiver)
+          if (wrapper_was_receiver)
             {
-              meta_x11_error_trap_push (x11_display);
-              meta_window_destroy_frame (window->frame->window);
-              meta_x11_error_trap_pop (x11_display);
+              meta_x11_display_unregister_x_window (x11_display,
+                                                    frame->wrapper_xwindow);
+              frame->wrapper_xwindow = None;
+            }
+          else if (frame_was_receiver)
+            {
+              meta_window_destroy_frame (frame->window);
             }
           else
             {
@@ -1437,7 +1445,7 @@ handle_other_xevent (MetaX11Display *x11_display,
           guint32 timestamp;
           timestamp = meta_display_get_current_time_roundtrip (display);
 
-          if (!frame_was_receiver)
+          if (!frame_was_receiver && !wrapper_was_receiver)
             {
               if (window->unmaps_pending == 0)
                 {
@@ -1530,7 +1538,7 @@ handle_other_xevent (MetaX11Display *x11_display,
           meta_verbose ("MapRequest on %s mapped = %d minimized = %d",
                         window->desc, window->mapped, window->minimized);
 
-          if (window->minimized && !frame_was_receiver)
+          if (window->minimized && !frame_was_receiver && !wrapper_was_receiver)
             {
               meta_window_unminimize (window);
               if (window->workspace != workspace_manager->active_workspace)
@@ -1594,7 +1602,7 @@ handle_other_xevent (MetaX11Display *x11_display,
                             xwcm, &xwc);
           meta_x11_error_trap_pop (x11_display);
         }
-      else if (!frame_was_receiver)
+      else if (!frame_was_receiver && !wrapper_was_receiver)
         {
           meta_window_x11_configure_request (window, event);
         }
@@ -1615,9 +1623,9 @@ handle_other_xevent (MetaX11Display *x11_display,
       {
         MetaGroup *group;
 
-        if (window && !frame_was_receiver)
+        if (window && !frame_was_receiver && !wrapper_was_receiver)
           meta_window_x11_property_notify (window, event);
-        else if (property_for_window && !frame_was_receiver)
+        else if (property_for_window && !frame_was_receiver && !wrapper_was_receiver)
           meta_window_x11_property_notify (property_for_window, event);
         else if (frame_was_receiver)
           meta_frame_handle_xevent (window->frame, event);
diff --git a/src/x11/window-props.c b/src/x11/window-props.c
index 6fbcf1ae6d..7bd5c57b82 100644
--- a/src/x11/window-props.c
+++ b/src/x11/window-props.c
@@ -950,10 +950,7 @@ reload_mwm_hints (MetaWindow    *window,
   /* We do all this anyhow at the end of meta_window_x11_new() */
   if (!window->constructing)
     {
-      if (window->decorated)
-        meta_window_ensure_frame (window);
-      else
-        meta_window_destroy_frame (window);
+      meta_window_sync_frame_state (window);
 
       meta_window_queue (window,
                          META_QUEUE_MOVE_RESIZE |
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 7ae5d8059b..2cc92fb044 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -563,7 +563,7 @@ meta_window_x11_manage (MetaWindow *window)
     update_sm_hints (window); /* must come after transient_for */
 
   if (window->decorated)
-    meta_window_ensure_frame (window);
+    meta_window_sync_frame_state (window);
   else
     meta_window_x11_initialize_state (window);
 }
@@ -1357,12 +1357,14 @@ meta_window_x11_move_resize_internal (MetaWindow                *window,
 
   /* The above client_rect is in root window coordinates. The
    * values we need to pass to XConfigureWindow are in parent
-   * coordinates, so if the window is in a frame, we need to
-   * correct the x/y positions here. */
+   * coordinates, so if the window is in a frame, it should be placed at 0,0,
+   * and the wrapper window needs to be placed we need to inside the frame
+   * window.
+   */
   if (window->frame)
     {
-      client_rect.x = borders.total.left;
-      client_rect.y = borders.total.top;
+      client_rect.x = 0;
+      client_rect.y = 0;
     }
 
   if (client_rect.x != priv->client_rect.x ||
@@ -1505,7 +1507,12 @@ meta_window_x11_move_resize_internal (MetaWindow                *window,
     }
 
   if (configure_frame_first && window->frame)
-    frame_shape_changed = meta_frame_sync_to_window (window->frame, need_resize_frame);
+    {
+      frame_shape_changed = meta_frame_sync_to_window (window->frame,
+                                                       client_rect.width,
+                                                       client_rect.height,
+                                                       need_resize_frame);
+    }
 
   if (mask != 0)
     {
@@ -1516,7 +1523,12 @@ meta_window_x11_move_resize_internal (MetaWindow                *window,
     }
 
   if (!configure_frame_first && window->frame)
-    frame_shape_changed = meta_frame_sync_to_window (window->frame, need_resize_frame);
+    {
+      frame_shape_changed = meta_frame_sync_to_window (window->frame,
+                                                       client_rect.width,
+                                                       client_rect.height,
+                                                       need_resize_frame);
+    }
 
   meta_x11_error_trap_pop (window->display->x11_display);
 
-- 
GitLab


From d62387957b6159f80e081a3319d9cd9329024594 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 29 Mar 2023 13:23:47 +0200
Subject: [PATCH 08/19] x11/frame: Unparent wrapper window when fullscreen

This hides the frame window, parenting the wrapper (and its child client
window) on top of the root window. This should again let us hit fast
paths in the X servers when fullscreen, improving performance for
decorated fullscreen windows.
---
 src/compositor/meta-surface-actor-x11.c |   2 +
 src/core/frame.c                        | 160 ++++++++++++++++++++----
 src/core/frame.h                        |   5 +-
 src/core/keybindings.c                  |   5 +-
 src/core/stack-tracker.c                |  21 +++-
 src/core/window.c                       |   4 +-
 src/wayland/meta-window-xwayland.c      |   2 +-
 src/x11/events.c                        |  12 +-
 src/x11/meta-x11-display.c              |  17 ++-
 src/x11/window-x11.c                    |   5 +-
 10 files changed, 184 insertions(+), 49 deletions(-)

diff --git a/src/compositor/meta-surface-actor-x11.c b/src/compositor/meta-surface-actor-x11.c
index 7834982e3b..34da578ba0 100644
--- a/src/compositor/meta-surface-actor-x11.c
+++ b/src/compositor/meta-surface-actor-x11.c
@@ -406,6 +406,8 @@ meta_surface_actor_x11_new (MetaWindow *window)
   create_damage (self);
   g_signal_connect_object (self->window, "notify::decorated",
                            G_CALLBACK (window_decorated_notify), self, 0);
+  g_signal_connect_object (self->window, "notify::fullscreen",
+                           G_CALLBACK (window_decorated_notify), self, 0);
 
   g_signal_connect_object (meta_window_actor_from_window (window), "destroy",
                            G_CALLBACK (release_x11_resources), self,
diff --git a/src/core/frame.c b/src/core/frame.c
index 4160189d44..b79735cec2 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -57,6 +57,83 @@ request_frame (MetaWindow *window)
   meta_x11_error_trap_pop (x11_display);
 }
 
+static void
+sync_frame_fullscreen_state (MetaWindow *window,
+                             gboolean    initial)
+{
+  MetaX11Display *x11_display = window->display->x11_display;
+  MetaFrame *frame = window->frame;
+  MetaFrameBorders borders;
+
+  if (window->fullscreen == frame->is_fullscreen && !initial)
+    return;
+
+  frame->is_fullscreen = window->fullscreen;
+
+  meta_x11_error_trap_push (x11_display);
+
+  meta_frame_calc_borders (frame, &borders);
+
+  if (frame->is_fullscreen)
+    {
+      unsigned long serial;
+
+      serial = XNextRequest (x11_display->xdisplay);
+      XReparentWindow (x11_display->xdisplay,
+                       frame->wrapper_xwindow,
+                       x11_display->xroot,
+                       window->frame->rect.x + borders.invisible.left,
+                       window->frame->rect.y + borders.invisible.top);
+      XUnmapWindow (x11_display->xdisplay,
+                    frame->xwindow);
+
+      meta_stack_tracker_record_add (window->display->stack_tracker,
+                                     frame->wrapper_xwindow,
+                                     serial);
+      if (!initial)
+        {
+          meta_stack_tracker_record_remove (window->display->stack_tracker,
+                                            frame->xwindow,
+                                            serial);
+        }
+    }
+  else
+    {
+      unsigned long serial;
+
+      serial = XNextRequest (x11_display->xdisplay);
+      XMapWindow (x11_display->xdisplay,
+                  frame->xwindow);
+      XReparentWindow (x11_display->xdisplay,
+                       frame->wrapper_xwindow,
+                       frame->xwindow,
+                       borders.total.left,
+                       borders.total.top);
+      window->reparents_pending += 1;
+      window->reparents_pending += 1;
+
+      meta_stack_tracker_record_add (window->display->stack_tracker,
+                                     frame->xwindow,
+                                     serial);
+      if (!initial)
+        {
+          meta_stack_tracker_record_remove (window->display->stack_tracker,
+                                            frame->wrapper_xwindow,
+                                            serial);
+        }
+    }
+  meta_x11_error_trap_pop (x11_display);
+
+  if (meta_window_has_focus (window))
+    window->restore_focus_on_map = TRUE;
+
+  /* Move keybindings to frame or wrapper instead of window */
+  meta_window_grab_keys (window);
+
+  meta_window_queue (window, META_QUEUE_CALC_SHOWING);
+  meta_window_queue (window, META_QUEUE_MOVE_RESIZE);
+}
+
 void
 meta_window_sync_frame_state (MetaWindow *window)
 {
@@ -67,6 +144,8 @@ meta_window_sync_frame_state (MetaWindow *window)
     meta_window_destroy_frame (window);
   else if (!window->frame)
     request_frame (window);
+  else
+    sync_frame_fullscreen_state (window, FALSE);
 }
 
 static void
@@ -187,14 +266,6 @@ meta_window_set_frame_xwindow (MetaWindow *window,
   meta_stack_tracker_record_remove (window->display->stack_tracker,
                                     window->xwindow,
                                     XNextRequest (x11_display->xdisplay));
-  XReparentWindow (x11_display->xdisplay,
-                   frame->wrapper_xwindow,
-                   frame->xwindow,
-                   frame->child_x,
-                   frame->child_y);
-
-  /* FIXME handle this error */
-  meta_x11_error_trap_pop (x11_display);
 
   /* Ensure focus is restored after the unmap/map events triggered
    * by XReparentWindow().
@@ -212,12 +283,10 @@ meta_window_set_frame_xwindow (MetaWindow *window,
                                             x11_display->atom__NET_WM_OPAQUE_REGION,
                                             TRUE);
 
-  meta_x11_error_trap_push (x11_display);
-  XMapWindow (x11_display->xdisplay, frame->xwindow);
-  meta_x11_error_trap_pop (x11_display);
+  sync_frame_fullscreen_state (window, TRUE);
 
-  /* Move keybindings to frame instead of window */
-  meta_window_grab_keys (window);
+  /* FIXME handle this error */
+  meta_x11_error_trap_pop (x11_display);
 
   /* Even though the property was already set, notify
    * on it so other bits of the machinery catch up
@@ -232,6 +301,7 @@ meta_window_destroy_frame (MetaWindow *window)
   MetaFrame *frame;
   MetaFrameBorders borders;
   MetaX11Display *x11_display;
+  unsigned long serial;
 
   if (window->frame == NULL)
     return;
@@ -287,6 +357,21 @@ meta_window_destroy_frame (MetaWindow *window)
                    window->xwindow,
                    x11_display->atom__MUTTER_NEEDS_FRAME);
 
+  serial = XNextRequest (x11_display->xdisplay);
+
+  if (frame->is_fullscreen)
+    {
+      meta_stack_tracker_record_remove (window->display->stack_tracker,
+                                        frame->wrapper_xwindow,
+                                        serial);
+    }
+  else
+    {
+      meta_stack_tracker_record_remove (window->display->stack_tracker,
+                                        frame->xwindow,
+                                        serial);
+    }
+
   if (frame->wrapper_xwindow != None)
     {
       XDestroyWindow (window->display->x11_display->xdisplay,
@@ -464,17 +549,35 @@ meta_frame_sync_to_window (MetaFrame *frame,
 
   meta_x11_error_trap_push (x11_display);
 
-  XMoveResizeWindow (window->display->x11_display->xdisplay,
-                     frame->wrapper_xwindow,
-                     borders.total.left, borders.total.top,
-                     client_width, client_height);
+  if (frame->is_fullscreen)
+    {
+      XMoveResizeWindow (window->display->x11_display->xdisplay,
+                         frame->wrapper_xwindow,
+                         frame->rect.x, frame->rect.y,
+                         frame->rect.width, frame->rect.height);
 
-  XMoveResizeWindow (x11_display->xdisplay,
-                     frame->xwindow,
-                     frame->rect.x,
-                     frame->rect.y,
-                     frame->rect.width,
-                     frame->rect.height);
+      XMoveWindow (window->display->x11_display->xdisplay,
+                   window->xwindow,
+                   0, 0);
+    }
+  else
+    {
+      XMoveResizeWindow (window->display->x11_display->xdisplay,
+                         frame->wrapper_xwindow,
+                         borders.total.left, borders.total.top,
+                         client_width, client_height);
+
+      XMoveWindow (window->display->x11_display->xdisplay,
+                   window->xwindow,
+                   0, 0);
+
+      XMoveResizeWindow (x11_display->xdisplay,
+                         frame->xwindow,
+                         frame->rect.x,
+                         frame->rect.y,
+                         frame->rect.width,
+                         frame->rect.height);
+    }
 
   meta_x11_error_trap_pop (x11_display);
 
@@ -519,11 +622,20 @@ meta_frame_get_mask (MetaFrame    *frame,
 }
 
 Window
-meta_frame_get_xwindow (MetaFrame *frame)
+meta_frame_get_frame_xwindow (MetaFrame *frame)
 {
   return frame->xwindow;
 }
 
+Window
+meta_frame_get_current_xwindow (MetaFrame *frame)
+{
+  if (frame->is_fullscreen)
+    return frame->wrapper_xwindow;
+  else
+    return frame->xwindow;
+}
+
 static void
 send_configure_notify (MetaFrame *frame)
 {
diff --git a/src/core/frame.h b/src/core/frame.h
index 90ad1f699c..2743bb8862 100644
--- a/src/core/frame.h
+++ b/src/core/frame.h
@@ -53,12 +53,15 @@ struct _MetaFrame
   int bottom_height;
 
   guint borders_cached : 1;
+  guint is_fullscreen : 1;
 };
 
 void     meta_window_sync_frame_state       (MetaWindow *window);
 void     meta_window_destroy_frame          (MetaWindow *window);
 
-Window         meta_frame_get_xwindow (MetaFrame *frame);
+Window meta_frame_get_frame_xwindow (MetaFrame *frame);
+
+Window meta_frame_get_current_xwindow (MetaFrame *frame);
 
 /* These should ONLY be called from meta_window_move_resize_internal */
 void meta_frame_calc_borders      (MetaFrame        *frame,
diff --git a/src/core/keybindings.c b/src/core/keybindings.c
index b25d993d8d..fda35440d8 100644
--- a/src/core/keybindings.c
+++ b/src/core/keybindings.c
@@ -1205,10 +1205,7 @@ meta_change_button_grab (MetaKeyBindingManager *keys,
 
   mtk_x11_error_trap_push (xdisplay);
 
-  if (window->frame)
-    xwindow = window->frame->xwindow;
-  else
-    xwindow = window->xwindow;
+  xwindow = meta_window_x11_get_toplevel_xwindow (window);
 
   /* GrabModeSync means freeze until XAllowEvents */
   if (grab)
diff --git a/src/core/stack-tracker.c b/src/core/stack-tracker.c
index 695ae2f9cf..90a4febf47 100644
--- a/src/core/stack-tracker.c
+++ b/src/core/stack-tracker.c
@@ -591,7 +591,7 @@ on_stack_changed (MetaStack        *stack,
 		  w->layer, w->stack_position, w->desc);
 
       if (w->frame)
-	top_level_window = w->frame->xwindow;
+	top_level_window = meta_frame_get_current_xwindow (w->frame);
       else
 	top_level_window = w->xwindow;
 
@@ -1048,11 +1048,20 @@ meta_stack_tracker_sync_stack (MetaStackTracker *tracker)
            */
           if (window)
             {
-              if (window->frame &&
-                  window->frame->xwindow == xwindow)
-                windows = g_list_prepend (windows, window);
-              else if (xwindow == window->xwindow)
-                windows = g_list_prepend (windows, window);
+              if (window->frame)
+                {
+                  if (window->frame->is_fullscreen &&
+                      window->frame->wrapper_xwindow == xwindow)
+                    windows = g_list_prepend (windows, window);
+                  else if (!window->frame->is_fullscreen &&
+                           window->frame->xwindow == xwindow)
+                    windows = g_list_prepend (windows, window);
+                }
+              else
+                {
+                  if (xwindow == window->xwindow)
+                    windows = g_list_prepend (windows, window);
+                }
             }
         }
       else
diff --git a/src/core/window.c b/src/core/window.c
index 4329f9b958..c29c42210a 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -4405,7 +4405,7 @@ meta_window_frame_rect_to_client_rect (MetaWindow   *window,
 
   *client_rect = *frame_rect;
 
-  if (window->frame)
+  if (window->frame && !window->frame->is_fullscreen)
     {
       MetaFrameBorders borders;
       meta_frame_calc_borders (window->frame, &borders);
@@ -4415,7 +4415,7 @@ meta_window_frame_rect_to_client_rect (MetaWindow   *window,
       client_rect->width  -= borders.visible.left + borders.visible.right;
       client_rect->height -= borders.visible.top  + borders.visible.bottom;
     }
-  else
+  else if (!window->frame)
     {
       const MetaFrameBorder *extents = &window->custom_frame_extents;
       client_rect->x -= extents->left;
diff --git a/src/wayland/meta-window-xwayland.c b/src/wayland/meta-window-xwayland.c
index ed3c679f1c..67a2bc4fdc 100644
--- a/src/wayland/meta-window-xwayland.c
+++ b/src/wayland/meta-window-xwayland.c
@@ -200,7 +200,7 @@ apply_allow_commits_x11_property (MetaWindowXwayland *xwayland_window,
   if (!frame)
     xwin = window->xwindow;
   else
-    xwin = meta_frame_get_xwindow (frame);
+    xwin = meta_frame_get_frame_xwindow (frame);
 
   if (!xwin)
     return;
diff --git a/src/x11/events.c b/src/x11/events.c
index 5074972352..b60e0e3a5f 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -1415,13 +1415,7 @@ handle_other_xevent (MetaX11Display *x11_display,
       }
       if (window)
         {
-          if (wrapper_was_receiver)
-            {
-              meta_x11_display_unregister_x_window (x11_display,
-                                                    frame->wrapper_xwindow);
-              frame->wrapper_xwindow = None;
-            }
-          else if (frame_was_receiver)
+          if (frame_was_receiver)
             {
               meta_window_destroy_frame (frame->window);
             }
@@ -1830,7 +1824,9 @@ window_has_xwindow (MetaWindow *window,
   if (window->xwindow == xwindow)
     return TRUE;
 
-  if (window->frame && window->frame->xwindow == xwindow)
+  if (window->frame &&
+      (window->frame->xwindow == xwindow ||
+       window->frame->wrapper_xwindow == xwindow))
     return TRUE;
 
   return FALSE;
diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 3b8fc78e0b..b002d36b20 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -2045,9 +2045,22 @@ meta_x11_display_set_input_focus (MetaX11Display *x11_display,
   gulong serial;
 
   if (window)
-    xwindow = focus_frame ? window->frame->xwindow : window->xwindow;
+    {
+      if (focus_frame)
+        {
+          g_return_if_fail (window->frame);
+
+          xwindow = meta_frame_get_current_xwindow (window->frame);
+        }
+      else
+        {
+          xwindow = window->xwindow;
+        }
+    }
   else
-    xwindow = x11_display->no_focus_window;
+    {
+      xwindow = x11_display->no_focus_window;
+    }
 
   meta_topic (META_DEBUG_FOCUS, "Setting X11 input focus for window %s to 0x%lx",
               window ? window->desc : "none", xwindow);
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 2cc92fb044..fac969363b 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -4263,7 +4263,10 @@ meta_window_x11_destroy_sync_request_alarm (MetaWindow *window)
 Window
 meta_window_x11_get_toplevel_xwindow (MetaWindow *window)
 {
-  return window->frame ? window->frame->xwindow : window->xwindow;
+  if (window->frame)
+    return meta_frame_get_current_xwindow (window->frame);
+  else
+    return window->xwindow;
 }
 
 void
-- 
GitLab


From e187742c56af118080bb83d4241355437d96e4f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Apr 2023 13:34:11 +0200
Subject: [PATCH 09/19] frame: Delete NEEDS_FRAME property even if we didn't
 get one

This fixes a race condition where we'd request a frame, then unrequest
it before we got the first frame we requeted. In that case, we'd miss
removing the property, which means the frames client would have it
lingering. The end result is that the next time we'd request one, we
wouldn't get a new frame window, since the frames client ignored the
request, thinking the old one still counts.
---
 src/core/frame.c          | 43 ++++++++++++++++++++++++++-------------
 src/core/window-private.h |  1 +
 2 files changed, 30 insertions(+), 14 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index b79735cec2..ab08700019 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -46,6 +46,9 @@ request_frame (MetaWindow *window)
   MetaX11Display *x11_display = window->display->x11_display;
   unsigned long data[1] = { 1 };
 
+  if (window->frame_pending)
+    return;
+
   meta_x11_error_trap_push (x11_display);
 
   XChangeProperty (x11_display->xdisplay,
@@ -53,6 +56,7 @@ request_frame (MetaWindow *window)
                    x11_display->atom__MUTTER_NEEDS_FRAME,
                    XA_CARDINAL,
                    32, PropModeReplace, (uint8_t *) data, 1);
+  window->frame_pending = TRUE;
 
   meta_x11_error_trap_pop (x11_display);
 }
@@ -180,9 +184,7 @@ init_wrapper_window (MetaFrame *frame)
                                           InputOutput,
                                           window->xvisual,
                                           mask, &xattr);
-  XSelectInput (x11_display->xdisplay,
-                frame->wrapper_xwindow,
-                StructureNotifyMask | SubstructureNotifyMask);
+  XSelectInput (x11_display->xdisplay, frame->wrapper_xwindow, EVENT_MASK);
 
   XReparentWindow (x11_display->xdisplay,
                    window->xwindow,
@@ -207,6 +209,8 @@ meta_window_set_frame_xwindow (MetaWindow *window,
   if (window->frame)
     return;
 
+  window->frame_pending = FALSE;
+
   frame = g_new0 (MetaFrame, 1);
 
   frame->window = window;
@@ -298,26 +302,36 @@ meta_window_set_frame_xwindow (MetaWindow *window,
 void
 meta_window_destroy_frame (MetaWindow *window)
 {
+  MetaX11Display *x11_display = window->display->x11_display;
   MetaFrame *frame;
   MetaFrameBorders borders;
-  MetaX11Display *x11_display;
   unsigned long serial;
 
   if (window->frame == NULL)
-    return;
+    {
+      if (window->frame_pending)
+        {
+          window->frame_pending = FALSE;
+          meta_x11_error_trap_push (x11_display);
+          XDeleteProperty (x11_display->xdisplay,
+                           window->xwindow,
+                           x11_display->atom__MUTTER_NEEDS_FRAME);
+          meta_x11_error_trap_pop (x11_display);
+        }
 
-  x11_display = window->display->x11_display;
+      meta_topic (META_DEBUG_WINDOW_STATE,
+                  "Unframing unframed window %s", window->desc);
+      return;
+    }
 
   meta_verbose ("Unframing window %s", window->desc);
 
   frame = window->frame;
 
+  meta_x11_error_trap_push (x11_display);
+
   meta_frame_calc_borders (frame, &borders);
 
-  /* Unparent the client window; it may be destroyed,
-   * thus the error trap.
-   */
-  meta_x11_error_trap_push (x11_display);
   if (window->mapped)
     {
       window->mapped = FALSE; /* Keep track of unmapping it, so we
@@ -353,10 +367,6 @@ meta_window_destroy_frame (MetaWindow *window)
   if (META_X11_DISPLAY_HAS_SHAPE (x11_display))
     XShapeSelectInput (x11_display->xdisplay, frame->xwindow, NoEventMask);
 
-  XDeleteProperty (x11_display->xdisplay,
-                   window->xwindow,
-                   x11_display->atom__MUTTER_NEEDS_FRAME);
-
   serial = XNextRequest (x11_display->xdisplay);
 
   if (frame->is_fullscreen)
@@ -382,6 +392,11 @@ meta_window_destroy_frame (MetaWindow *window)
       frame->wrapper_xwindow = None;
     }
 
+  window->frame_pending = FALSE;
+  XDeleteProperty (x11_display->xdisplay,
+                   window->xwindow,
+                   x11_display->atom__MUTTER_NEEDS_FRAME);
+
   meta_x11_error_trap_pop (x11_display);
 
   /* Ensure focus is restored after the unmap/map events triggered
diff --git a/src/core/window-private.h b/src/core/window-private.h
index fc5fac8325..5331bf5046 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -180,6 +180,7 @@ struct _MetaWindow
   Window xwindow;
   /* may be NULL! not all windows get decorated */
   MetaFrame *frame;
+  gboolean frame_pending;
   int depth;
   Visual *xvisual;
   char *desc; /* used in debug spew */
-- 
GitLab


From 9e6e856e42eef10830e117d947f7f52a8cbfc77e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Apr 2023 14:48:43 +0200
Subject: [PATCH 10/19] core: Turn some meta_verbose() into meta_topic()

Some window state changes were turned from meta_verbose() into
meta_topic() with the debug scope META_DEBUG_WINDOW_STATE.

The window frame debug logging was also folded into
META_DEBUG_WINDOW_STATE and also expanded to include some more state
transitions.

A couple of more previously unlogged window op changes were also
added: minimize & unminimize.
---
 src/core/frame.c     | 26 ++++++++++++++------------
 src/core/window.c    | 27 +++++++++++++++++++--------
 src/x11/events.c     |  3 ++-
 src/x11/window-x11.c |  3 +++
 4 files changed, 38 insertions(+), 21 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index ab08700019..6c50dbd131 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -51,6 +51,9 @@ request_frame (MetaWindow *window)
 
   meta_x11_error_trap_push (x11_display);
 
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Requesting frame for window %s", window->desc);
+
   XChangeProperty (x11_display->xdisplay,
                    window->xwindow,
                    x11_display->atom__MUTTER_NEEDS_FRAME,
@@ -228,21 +231,19 @@ meta_window_set_frame_xwindow (MetaWindow *window,
 
   window->frame = frame;
 
-  meta_verbose ("Frame geometry %d,%d  %dx%d",
-                frame->rect.x, frame->rect.y,
-                frame->rect.width, frame->rect.height);
-
-  meta_verbose ("Setting frame 0x%lx for window %s, "
-                "frame geometry %d,%d  %dx%d",
-                xframe, window->desc,
-                frame->rect.x, frame->rect.y,
-                frame->rect.width, frame->rect.height);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Setting frame 0x%lx for window %s, "
+              "frame geometry %d,%d  %dx%d",
+              xframe, window->desc,
+              frame->rect.x, frame->rect.y,
+              frame->rect.width, frame->rect.height);
 
   meta_stack_tracker_record_add (window->display->stack_tracker,
                                  frame->xwindow,
                                  create_serial);
 
-  meta_verbose ("Frame for %s is 0x%lx", frame->window->desc, frame->xwindow);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Frame for %s is 0x%lx", frame->window->desc, frame->xwindow);
 
   meta_x11_error_trap_push (x11_display);
 
@@ -324,7 +325,7 @@ meta_window_destroy_frame (MetaWindow *window)
       return;
     }
 
-  meta_verbose ("Unframing window %s", window->desc);
+  meta_topic (META_DEBUG_WINDOW_STATE, "Unframing window %s", window->desc);
 
   frame = window->frame;
 
@@ -553,8 +554,9 @@ meta_frame_sync_to_window (MetaFrame *frame,
   meta_frame_calc_borders (window->frame, &borders);
 
   meta_topic (META_DEBUG_GEOMETRY,
-              "Syncing frame geometry %d,%d %dx%d (SE: %d,%d), "
+              "Syncing %s frame geometry %d,%d %dx%d (SE: %d,%d), "
               "wrapper: %d,%d %dx%d",
+              frame->window->desc,
               frame->rect.x, frame->rect.y,
               frame->rect.width, frame->rect.height,
               frame->rect.x + frame->rect.width,
diff --git a/src/core/window.c b/src/core/window.c
index c29c42210a..bcc3c8c827 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -1186,7 +1186,8 @@ meta_window_constructed (GObject *object)
     {
       /* WM_HINTS said minimized */
       window->minimized = TRUE;
-      meta_verbose ("Window %s asked to start out minimized", window->desc);
+      meta_topic (META_DEBUG_WINDOW_STATE,
+                  "Window %s asked to start out minimized", window->desc);
     }
 
   /* Apply any window attributes such as initial workspace
@@ -1426,7 +1427,8 @@ meta_window_unmanage (MetaWindow  *window,
   MetaWorkspaceManager *workspace_manager = window->display->workspace_manager;
   GList *tmp;
 
-  meta_verbose ("Unmanaging %s", window->desc);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Unmanaging %s", window->desc);
   window->unmanaging = TRUE;
 
   g_clear_handle_id (&priv->suspend_timoeut_id, g_source_remove);
@@ -1676,8 +1678,9 @@ meta_window_showing_on_its_workspace (MetaWindow *window)
       workspace_of_window && workspace_of_window->showing_desktop &&
       !is_desktop_or_dock)
     {
-      meta_verbose ("We're showing the desktop on the workspace(s) that window %s is on",
-                    window->desc);
+      meta_topic (META_DEBUG_WINDOW_STATE,
+                  "We're showing the desktop on the workspace(s) that window %s is on",
+                  window->desc);
       showing = FALSE;
     }
 
@@ -1744,8 +1747,9 @@ implement_showing (MetaWindow *window,
                    gboolean    showing)
 {
   /* Actually show/hide the window */
-  meta_verbose ("Implement showing = %d for window %s",
-                showing, window->desc);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Implement showing = %d for window %s",
+              showing, window->desc);
 
   /* Some windows are not stackable until being showed, so add those now. */
   if (meta_window_is_stackable (window) && !meta_window_is_in_stack (window))
@@ -2529,6 +2533,9 @@ meta_window_minimize (MetaWindow  *window)
 
   if (!window->minimized)
     {
+      meta_topic (META_DEBUG_WINDOW_OPS, "Minimizing window %s",
+                  window->desc);
+
       window->minimized = TRUE;
       window->pending_compositor_effect = META_COMP_EFFECT_MINIMIZE;
       meta_window_queue(window, META_QUEUE_CALC_SHOWING);
@@ -2561,6 +2568,9 @@ meta_window_unminimize (MetaWindow  *window)
 
   if (window->minimized)
     {
+      meta_topic (META_DEBUG_WINDOW_OPS, "Unminimizing window %s",
+                  window->desc);
+
       window->minimized = FALSE;
       window->pending_compositor_effect = META_COMP_EFFECT_UNMINIMIZE;
       meta_window_queue(window, META_QUEUE_CALC_SHOWING);
@@ -4883,8 +4893,9 @@ meta_window_change_workspace (MetaWindow    *window,
 static void
 window_stick_impl (MetaWindow  *window)
 {
-  meta_verbose ("Sticking window %s current on_all_workspaces = %d",
-                window->desc, window->on_all_workspaces);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Sticking window %s current on_all_workspaces = %d",
+              window->desc, window->on_all_workspaces);
 
   if (window->on_all_workspaces_requested)
     return;
diff --git a/src/x11/events.c b/src/x11/events.c
index b60e0e3a5f..73702b9087 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -1456,7 +1456,8 @@ handle_other_xevent (MetaX11Display *x11_display,
                 {
                   window->unmaps_pending -= 1;
                   meta_topic (META_DEBUG_WINDOW_STATE,
-                              "Received pending unmap, %d now pending",
+                              "Received pending unmap on %s, %d now pending",
+                              window->desc,
                               window->unmaps_pending);
                 }
             }
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index fac969363b..7a8b29617c 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -2071,6 +2071,9 @@ meta_window_x11_unmap (MetaWindow *window)
   meta_x11_error_trap_push (x11_display);
   XUnmapWindow (x11_display->xdisplay, window->xwindow);
   meta_x11_error_trap_pop (x11_display);
+  meta_topic (META_DEBUG_WINDOW_STATE,
+              "Increasing unmaps_pending due to unmapping window %s",
+              window->desc);
   window->unmaps_pending ++;
 }
 
-- 
GitLab


From a203d44944739171e495df54726b3552f78c522a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 4 Apr 2023 10:53:56 +0200
Subject: [PATCH 11/19] tests/x11: Clean up test script

Some log entries were not logged to stderr, and a PID was wrong.
---
 src/tests/x11-test.sh | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/tests/x11-test.sh b/src/tests/x11-test.sh
index 59e460fc33..585586994a 100755
--- a/src/tests/x11-test.sh
+++ b/src/tests/x11-test.sh
@@ -16,7 +16,7 @@ echo \# Launching mutter > /dev/stderr
 $MUTTER --x11 --mutter-plugin="$MUTTER_TEST_PLUGIN_PATH" &
 MUTTER1_PID=$!
 gdbus wait --session org.gnome.Mutter.IdleMonitor
-echo \# Launched with pid $MUTTER1_PID
+echo \# Launched with pid $MUTTER1_PID > /dev/stderr
 
 sleep 2
 
@@ -30,9 +30,10 @@ sleep 4
 
 echo \# Replacing existing mutter with a new instance > /dev/stderr
 $MUTTER --x11 --replace --mutter-plugin="$MUTTER_TEST_PLUGIN_PATH" &
-echo \# Launched with pid $MUTTER2_PID
 MUTTER2_PID=$!
+echo \# Launched with pid $MUTTER2_PID > /dev/stderr
 wait $MUTTER1_PID
+echo \# Mutter \($MUTTER1_PID\) exited with $? > /dev/stderr
 
 sleep 2
 
@@ -45,3 +46,4 @@ sleep 1
 echo \# Terminating mutter > /dev/stderr
 kill $MUTTER2_PID
 wait $MUTTER2_PID
+echo \# Mutter \($MUTTER2_PID\) exited with $? > /dev/stderr
-- 
GitLab


From a6f3ec047d44b060de230f0176314c68ad31330d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 4 Apr 2023 18:17:59 +0200
Subject: [PATCH 12/19] test/runner: Synchronize with frames client when
 waiting

When metatest do 'wait', it is expected that all actions have completed
in every place. This was not true for actions that involved the frames
client, as we could have sent a request (e.g. changed a window
property), round tripped to the X server, and round tripped all the test
clients themselves. What we hadn't done is ensure that all the requests
we expected to have the frames client handled had been seen by the X
server.

To achieve this, introduce another root window property called
`_MUTTER_FRAME_SYNC_SERIALS`. It's a two sized XA_CARDINAL (two
numbers). Whenever the test runner needs to "wait", it'll set the first
of the two to an ever increasing counter, and wait for the second value
to have been updated to match the first.

The frames client is changed to listen on property changes on the same
atom, and will take whatever it sees in the first number, and write it
to the second.

This way we can be sure property changes we sent to the frames client
have been fully processed.

This fixes flakyness of the `closed-transient-only-take-focus-parents`
test.
---
 src/frames/meta-window-tracker.c | 40 +++++++++++++++++++++
 src/tests/meta-test-utils.c      | 61 ++++++++++++++++++++++++++++++++
 src/x11/atomnames.h              |  1 +
 3 files changed, 102 insertions(+)

diff --git a/src/frames/meta-window-tracker.c b/src/frames/meta-window-tracker.c
index 8460f90072..b21306d517 100644
--- a/src/frames/meta-window-tracker.c
+++ b/src/frames/meta-window-tracker.c
@@ -221,6 +221,39 @@ remove_frame (MetaWindowTracker *window_tracker,
                        GUINT_TO_POINTER (xframe));
 }
 
+static void
+sync_frame_serials (GdkDisplay *display)
+{
+  Display *xdisplay = gdk_x11_display_get_xdisplay (display);
+  Window xroot = gdk_x11_display_get_xrootwindow (display);
+  Atom frame_sync_serials_atom;
+  int format;
+  Atom type;
+  unsigned long nitems, bytes_after;
+  unsigned long *data = NULL;
+
+  frame_sync_serials_atom =
+    gdk_x11_get_xatom_by_name_for_display (display,
+                                           "_MUTTER_FRAME_SYNC_SERIALS");
+
+  XGetWindowProperty (xdisplay, xroot, frame_sync_serials_atom,
+                      0, 2,
+                      False, XA_CARDINAL,
+                      &type, &format,
+                      &nitems, &bytes_after,
+                      (uint8_t **) &data);
+
+  if (data && data[0] != data[1])
+    {
+      data[1] = data[0];
+
+      XChangeProperty (xdisplay, xroot, frame_sync_serials_atom,
+                       XA_CARDINAL,
+                       32, PropModeReplace, (uint8_t *) data, 2);
+    }
+  XFree (data);
+}
+
 static gboolean
 on_xevent (GdkDisplay *display,
            XEvent     *xevent,
@@ -258,6 +291,12 @@ on_xevent (GdkDisplay *display,
                                       GUINT_TO_POINTER (xwindow)))
         remove_frame (window_tracker, xwindow);
     }
+  else if (xevent->type == PropertyNotify &&
+           xevent->xproperty.atom ==
+           gdk_x11_get_xatom_by_name_for_display (display, "_MUTTER_FRAME_SYNC_SERIALS"))
+    {
+      sync_frame_serials (display);
+    }
   else if (xevent->type == PropertyNotify)
     {
       frame = g_hash_table_lookup (window_tracker->frames,
@@ -346,6 +385,7 @@ meta_window_tracker_constructed (GObject *object)
 
   g_signal_connect (display, "xevent",
                     G_CALLBACK (on_xevent), object);
+  sync_frame_serials (display);
 
   gdk_x11_display_error_trap_push (display);
 
diff --git a/src/tests/meta-test-utils.c b/src/tests/meta-test-utils.c
index 3cbff77ae4..6939638a73 100644
--- a/src/tests/meta-test-utils.c
+++ b/src/tests/meta-test-utils.c
@@ -23,6 +23,7 @@
 
 #include <gio/gio.h>
 #include <string.h>
+#include <X11/Xatom.h>
 #include <X11/Xlib-xcb.h>
 
 #include "backends/meta-monitor-config-store.h"
@@ -376,6 +377,63 @@ meta_test_client_run (MetaTestClient *client,
     }
 }
 
+static void
+wait_frames_client (MetaContext *context)
+{
+  MetaDisplay *display = meta_context_get_display (context);
+  MetaX11Display *x11_display;
+  static unsigned long serial_counter = 0;
+  unsigned long desync_serial;
+  unsigned long desync_data[2] = {};
+
+  x11_display = meta_display_get_x11_display (display);
+  if (!x11_display)
+    return;
+
+  if (!x11_display->frames_client)
+    return;
+
+  desync_serial = ++serial_counter;
+  desync_data[0] = desync_serial;
+
+  XChangeProperty (x11_display->xdisplay,
+                   x11_display->xroot,
+                   x11_display->atom__MUTTER_FRAME_SYNC_SERIALS,
+                   XA_CARDINAL,
+                   32, PropModeReplace, (uint8_t *) desync_data, 2);
+
+  while (TRUE)
+    {
+      int format;
+      Atom type;
+      unsigned long nitems, bytes_after;
+      unsigned long *sync_data = NULL;
+
+      if (!x11_display->frames_client)
+        break;
+
+      XGetWindowProperty (x11_display->xdisplay,
+                          x11_display->xroot,
+                          x11_display->atom__MUTTER_FRAME_SYNC_SERIALS,
+                          0, 2,
+                          False, XA_CARDINAL,
+                          &type, &format,
+                          &nitems, &bytes_after,
+                          (uint8_t **) &sync_data);
+
+      if (sync_data &&
+          sync_data[0] == desync_serial &&
+          sync_data[1] == desync_serial)
+        {
+          XFree (sync_data);
+          break;
+        }
+
+      XFree (sync_data);
+      g_main_context_iteration (NULL, TRUE);
+    }
+}
+
 gboolean
 meta_test_client_wait (MetaTestClient  *client,
                        GError         **error)
@@ -400,6 +458,9 @@ meta_test_client_wait (MetaTestClient  *client,
         return FALSE;
 
       meta_async_waiter_wait (client->waiter, wait_value);
+
+      wait_frames_client (client->context);
+
       return TRUE;
     }
 }
diff --git a/src/x11/atomnames.h b/src/x11/atomnames.h
index 644dbefee6..a7f4bcc7da 100644
--- a/src/x11/atomnames.h
+++ b/src/x11/atomnames.h
@@ -74,6 +74,7 @@ item(_MUTTER_VERSION)
 item(_MUTTER_FRAME_FOR)
 item(_MUTTER_FRAME_EXTENTS)
 item(_MUTTER_NEEDS_FRAME)
+item(_MUTTER_FRAME_SYNC_SERIALS)
 item(WM_CLIENT_MACHINE)
 item(MANAGER)
 item(TARGETS)
-- 
GitLab


From e956569de99b8734ea378715f1991ae097b79e40 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Wed, 12 Apr 2023 11:52:36 +0200
Subject: [PATCH 13/19] x11: Avoid redundant client window resizes

The client window is already invariably positioned at the 0,0 position
of its parent wrapper window, we do not need to doubly reposition
it when repositioning the frame window (which may also happen
before or after the client window, depending on the resize direction).
---
 src/core/frame.c | 11 ++---------
 1 file changed, 2 insertions(+), 9 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index 6c50dbd131..737dd6fa27 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -572,21 +572,14 @@ meta_frame_sync_to_window (MetaFrame *frame,
                          frame->wrapper_xwindow,
                          frame->rect.x, frame->rect.y,
                          frame->rect.width, frame->rect.height);
-
-      XMoveWindow (window->display->x11_display->xdisplay,
-                   window->xwindow,
-                   0, 0);
     }
   else
     {
       XMoveResizeWindow (window->display->x11_display->xdisplay,
                          frame->wrapper_xwindow,
                          borders.total.left, borders.total.top,
-                         client_width, client_height);
-
-      XMoveWindow (window->display->x11_display->xdisplay,
-                   window->xwindow,
-                   0, 0);
+                         frame->rect.width - borders.total.left - borders.total.right,
+                         frame->rect.height - borders.total.top - borders.total.bottom);
 
       XMoveResizeWindow (x11_display->xdisplay,
                          frame->xwindow,
-- 
GitLab


From af69ea659bd3d8968f3501cc7fe88c5a096f2125 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Wed, 12 Apr 2023 23:25:15 +0200
Subject: [PATCH 14/19] core: Set wrapper window event mask once on creation

Avoid the SubstructureNotifyMask being set in the wrong place
and entirely, since it's not necessary and triggers more reparenting
events (emitted towards the wrapper, and its parent) than there are
reparents.

Also avoid the XSelectInput() call after XCreateWindow by passing the
correct event mask on creation.
---
 src/core/frame.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index 737dd6fa27..f645839560 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -166,7 +166,7 @@ init_wrapper_window (MetaFrame *frame)
   xattr.background_pixel = BlackPixel (x11_display->xdisplay,
                                        DefaultScreen (x11_display->xdisplay));
   xattr.border_pixel = xattr.background_pixel;
-  xattr.event_mask = StructureNotifyMask | PropertyChangeMask;
+  xattr.event_mask = EVENT_MASK;
   xattr.bit_gravity = NorthWestGravity;
   xattr.colormap =
     XCreateColormap (x11_display->xdisplay,
@@ -174,8 +174,7 @@ init_wrapper_window (MetaFrame *frame)
                      window->xvisual,
                      AllocNone);
 
-  mask = (CWBorderPixel | CWColormap | CWEventMask | CWBitGravity |
-          SubstructureNotifyMask);
+  mask = (CWBorderPixel | CWColormap | CWEventMask | CWBitGravity);
 
   frame->wrapper_xwindow = XCreateWindow (x11_display->xdisplay,
                                           frame->xwindow,
@@ -187,7 +186,6 @@ init_wrapper_window (MetaFrame *frame)
                                           InputOutput,
                                           window->xvisual,
                                           mask, &xattr);
-  XSelectInput (x11_display->xdisplay, frame->wrapper_xwindow, EVENT_MASK);
 
   XReparentWindow (x11_display->xdisplay,
                    window->xwindow,
-- 
GitLab


From 1a66fb3cb1e48c27ec5c58afd20e329f94d76809 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Fri, 21 Apr 2023 21:31:06 +0200
Subject: [PATCH 15/19] core: Do not select SubstructureNotify on both
 frame/wrapper windows

With the introduction of an extra window in the frame hierarchy, and the
selection for Structure and Substructure notification event masks in both
frame and wrapper windows, we receive an excess of ReparentNotify events
for every operation involving window reparenting. One event from the window
being reparented itself (e.g. the wrapper window, through StructureNotifyMask),
and other possible set of events from its old/new parents (depending on the
window being reparented, either of the root, frame, or wrapper window).

We do require SubstructureNotifyMask on the wrapper window in order to receive
DestroyNotify/MapNotify and other desirable events from client windows, and we
do also require it on the root window to track new windows. In order to minimize
the overlap, avoid any of these events on the frame window (already notified
through the root window), and set StructureNotifyMask|SubstructureNotifyMask on
the wrapper window to track changes from there downwards.

This leaves just one excess ReparentNotify maybe triggering
`window->reparents_pending` accounting, which is the one emitted on the root
window after the client window gets reparented to the wrapper window. Ignore
this one for MetaWindow accounting purposes, which makes the accounting nicely
even.
---
 src/core/frame.c | 8 ++++----
 src/x11/events.c | 3 ++-
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index f645839560..addd9b64f7 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -36,9 +36,9 @@
 #include <X11/Xatom.h>
 #include <X11/extensions/shape.h>
 
-#define EVENT_MASK (SubstructureRedirectMask |                     \
-                    StructureNotifyMask | SubstructureNotifyMask | \
-                    PropertyChangeMask | FocusChangeMask)
+#define EVENT_MASK (SubstructureRedirectMask | \
+                    PropertyChangeMask | \
+                    FocusChangeMask)
 
 static void
 request_frame (MetaWindow *window)
@@ -166,7 +166,7 @@ init_wrapper_window (MetaFrame *frame)
   xattr.background_pixel = BlackPixel (x11_display->xdisplay,
                                        DefaultScreen (x11_display->xdisplay));
   xattr.border_pixel = xattr.background_pixel;
-  xattr.event_mask = EVENT_MASK;
+  xattr.event_mask = EVENT_MASK | StructureNotifyMask | SubstructureNotifyMask;
   xattr.bit_gravity = NorthWestGravity;
   xattr.colormap =
     XCreateColormap (x11_display->xdisplay,
diff --git a/src/x11/events.c b/src/x11/events.c
index 73702b9087..0c03ef1f3e 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -1548,7 +1548,8 @@ handle_other_xevent (MetaX11Display *x11_display,
       break;
     case ReparentNotify:
       {
-        if (window && window->reparents_pending > 0)
+        if (event->xreparent.event != x11_display->xroot &&
+            window && window->reparents_pending > 0)
           window->reparents_pending -= 1;
         if (event->xreparent.event == x11_display->xroot)
           meta_stack_tracker_reparent_event (display->stack_tracker,
-- 
GitLab


From 68473948cddcb42df0ab9de91e6ce19acbb0f3c0 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Fri, 21 Apr 2023 13:19:49 +0200
Subject: [PATCH 16/19] core: Fix reparent event accounting

There's one too many in one branch handling fullscreen changes,
and not enough in the other. Even this out.
---
 src/core/frame.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index addd9b64f7..83f05c1acd 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -93,6 +93,7 @@ sync_frame_fullscreen_state (MetaWindow *window,
                        window->frame->rect.y + borders.invisible.top);
       XUnmapWindow (x11_display->xdisplay,
                     frame->xwindow);
+      window->reparents_pending += 1;
 
       meta_stack_tracker_record_add (window->display->stack_tracker,
                                      frame->wrapper_xwindow,
@@ -117,7 +118,6 @@ sync_frame_fullscreen_state (MetaWindow *window,
                        borders.total.left,
                        borders.total.top);
       window->reparents_pending += 1;
-      window->reparents_pending += 1;
 
       meta_stack_tracker_record_add (window->display->stack_tracker,
                                      frame->xwindow,
-- 
GitLab


From 7596c4b70ea81147fa4538abd19eeb8a655f8307 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 11 May 2023 13:52:58 +0200
Subject: [PATCH 17/19] x11: Simplify check for whether it's appropriate window
 resizing time

We are pretty much duplicating the checks from meta_window_updates_are_frozen()
that result in meta_window_x11_are_updates_frozen(). Perform the higher level
call here so that the code is clearer.
---
 src/x11/window-x11.c | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 7a8b29617c..5bde2ed845 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -4429,15 +4429,9 @@ meta_window_x11_is_awaiting_sync_response (MetaWindow *window)
 void
 meta_window_x11_check_update_resize (MetaWindow *window)
 {
-  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
   MetaWindowDrag *window_drag;
 
-  if (window->frame &&
-      meta_sync_counter_is_waiting (meta_frame_get_sync_counter (window->frame)))
-    return;
-
-  if (meta_sync_counter_is_waiting (&priv->sync_counter))
+  if (meta_window_updates_are_frozen (window))
     return;
 
   window_drag =
-- 
GitLab


From 68407d2643e591922d312ed4e071ee31306563a9 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 11 May 2023 13:54:43 +0200
Subject: [PATCH 18/19] core: Add API to fetch MetaFrame frozen/thawed state

Instead of poking at its internal MetaSyncCounter, add this call
so that the frame may also check for fullscreen state, meaning the
frame window is out of commission and does not preclude the window
from being thawed and updated.
---
 src/core/frame.c     | 9 +++++++++
 src/core/frame.h     | 2 ++
 src/x11/window-x11.c | 3 +--
 3 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/core/frame.c b/src/core/frame.c
index 83f05c1acd..e55ec0168b 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -802,3 +802,12 @@ meta_frame_set_opaque_region (MetaFrame      *frame,
 
   meta_compositor_window_shape_changed (window->display->compositor, window);
 }
+
+gboolean
+meta_frame_is_frozen (MetaFrame *frame)
+{
+  if (frame->is_fullscreen)
+    return FALSE;
+
+  return meta_sync_counter_is_waiting (&frame->sync_counter);
+}
diff --git a/src/core/frame.h b/src/core/frame.h
index 2743bb8862..f6d755b6f4 100644
--- a/src/core/frame.h
+++ b/src/core/frame.h
@@ -90,3 +90,5 @@ MetaSyncCounter * meta_frame_get_sync_counter (MetaFrame *frame);
 
 void meta_frame_set_opaque_region (MetaFrame      *frame,
                                    cairo_region_t *region);
+
+gboolean meta_frame_is_frozen (MetaFrame *frame);
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 5bde2ed845..3a0ea52e65 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -1917,8 +1917,7 @@ meta_window_x11_are_updates_frozen (MetaWindow *window)
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
 
-  if (window->frame &&
-      meta_sync_counter_is_waiting (meta_frame_get_sync_counter (window->frame)))
+  if (window->frame && meta_frame_is_frozen (window->frame))
     return TRUE;
 
   return meta_sync_counter_is_waiting (&priv->sync_counter);
-- 
GitLab


From ba0c5a94012d9c194779596f10f64fba1b216f1f Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 11 May 2023 13:58:47 +0200
Subject: [PATCH 19/19] core: Update frozen/thawed window state on fullscreen
 changes

Since we maybe change the conditions on whether the window is frozen
during fullscreen changes, check the window actor state is up-to-date.
---
 src/core/frame.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/core/frame.c b/src/core/frame.c
index e55ec0168b..58eedc6edc 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -137,6 +137,7 @@ sync_frame_fullscreen_state (MetaWindow *window,
   /* Move keybindings to frame or wrapper instead of window */
   meta_window_grab_keys (window);
 
+  meta_compositor_sync_updates_frozen (window->display->compositor, window);
   meta_window_queue (window, META_QUEUE_CALC_SHOWING);
   meta_window_queue (window, META_QUEUE_MOVE_RESIZE);
 }
-- 
GitLab

