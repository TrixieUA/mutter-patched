From b50d6404d5a1e0ea27531e85b1845a4685362a37 Mon Sep 17 00:00:00 2001
From: Gergo Koteles <soyer@irl.hu>
Date: Wed, 19 Jul 2023 01:19:16 +0200
Subject: [PATCH 1/7] wayland: Find touch grab sequence in subsurfaces also

With libdecor, window moving/resizing only works with
the pointer, not with touch.
The meta_wayland_pointer_can_grab_surface checks for subsurfaces,
but the meta_wayland_touch_find_grab_sequence does not.

Add a similar subsurface check to
meta_wayland_touch_find_grab_sequence.

Closes: GNOME/mutter#2872
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3125>

(cherry picked from commit 7b04e8be157b64dc52e3069752bf753a243ad51f)
---
 src/wayland/meta-wayland-touch.c | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-touch.c b/src/wayland/meta-wayland-touch.c
index 6d45b4b7b30..37e1a611c66 100644
--- a/src/wayland/meta-wayland-touch.c
+++ b/src/wayland/meta-wayland-touch.c
@@ -553,6 +553,25 @@ meta_wayland_touch_can_popup (MetaWaylandTouch *touch,
   return FALSE;
 }
 
+static gboolean
+touch_can_grab_surface (MetaWaylandTouchInfo *touch_info,
+                        MetaWaylandSurface   *surface)
+{
+  MetaWaylandSurface *subsurface;
+
+  if (touch_info->touch_surface->surface == surface)
+    return TRUE;
+
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface)
+    {
+      if (touch_can_grab_surface (touch_info, subsurface))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 ClutterEventSequence *
 meta_wayland_touch_find_grab_sequence (MetaWaylandTouch   *touch,
                                        MetaWaylandSurface *surface,
@@ -571,7 +590,7 @@ meta_wayland_touch_find_grab_sequence (MetaWaylandTouch   *touch,
                                  (gpointer*) &touch_info))
     {
       if (touch_info->slot_serial == serial &&
-	  touch_info->touch_surface->surface == surface)
+          touch_can_grab_surface (touch_info, surface))
         return sequence;
     }
 
-- 
GitLab


From 215d90286712390ee4f87c813ad523abbc6e5288 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Wed, 12 Jul 2023 18:42:47 +0800
Subject: [PATCH 2/7] stage-impl: Blit damage regions of all ages when using a
 shadow FB

Original idea by Gert van de Kraats, modified to avoid having an
unused intermediate swap_region.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/2602
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3117>

(cherry picked from commit 626498348b96e7ebdb2ab90fb7d2b3446578333a)
---
 src/backends/meta-stage-impl.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/backends/meta-stage-impl.c b/src/backends/meta-stage-impl.c
index db94c7e40a4..daa5c90d25d 100644
--- a/src/backends/meta-stage-impl.c
+++ b/src/backends/meta-stage-impl.c
@@ -600,10 +600,12 @@ meta_stage_impl_redraw_view_primary (MetaStageImpl    *stage_impl,
    * artefacts.
    */
   /* swap_region does not need damage history, set it up before that */
-  if (use_clipped_redraw)
-    swap_region = cairo_region_copy (fb_clip_region);
-  else
+  if (!use_clipped_redraw)
     swap_region = cairo_region_create ();
+  else if (clutter_stage_view_has_shadowfb (stage_view))
+    swap_region = cairo_region_reference (fb_clip_region);
+  else
+    swap_region = cairo_region_copy (fb_clip_region);
 
   swap_with_damage = FALSE;
   if (has_buffer_age)
-- 
GitLab


From 4f652140596888640e7fc6f725fc7d3123ad42b0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 27 Jun 2023 12:09:13 +0200
Subject: [PATCH 3/7] frames: Fix XGetWMNormalHints return value check

It returns non-0 if there are any hints in the WM_NORMAL_HINTS
property, 0 if there are none.

Fixes the mouse cursor changing to the resize shape over the decorations
of non-resizable windows.

Fixes: c7b3d8c607ae ("frames: Push error traps around various X11 calls")
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3096>

(cherry picked from commit e95499038d36db47c0eb920ae9aec632e87931c2)
---
 src/frames/meta-frame.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/frames/meta-frame.c b/src/frames/meta-frame.c
index 345751ad148..edb7378e047 100644
--- a/src/frames/meta-frame.c
+++ b/src/frames/meta-frame.c
@@ -446,10 +446,10 @@ frame_sync_wm_normal_hints (GtkWindow *frame,
 
   gdk_x11_display_error_trap_push (display);
 
-  if (XGetWMNormalHints (gdk_x11_display_get_xdisplay (display),
-                         client_window,
-                         &size_hints,
-                         &nitems) != Success)
+  if (!XGetWMNormalHints (gdk_x11_display_get_xdisplay (display),
+                          client_window,
+                          &size_hints,
+                          &nitems))
     {
       gdk_x11_display_error_trap_pop_ignored (display);
       return;
-- 
GitLab


From 6a2749c8e1fb29ebdbaf5a0570ad6acbdc056eb3 Mon Sep 17 00:00:00 2001
From: Sebastian Keller <skeller@gnome.org>
Date: Wed, 31 May 2023 14:14:04 +0200
Subject: [PATCH 4/7] constraints: Delay initial maximization until after
 reparenting is done

For SSD windows the decoration window from the frames client might have
a different maximization state than the client window and would end up
restoring it once shown. Avoid this issue by waiting until all
reparenting is done before applying the initial maximization (and
minimization).

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/2579
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3035>

(cherry picked from commit 7faf4a308efba78728db365bb1a0759f71d36231)
---
 src/core/constraints.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/core/constraints.c b/src/core/constraints.c
index 9a5398d1ac5..fe4ef407a14 100644
--- a/src/core/constraints.c
+++ b/src/core/constraints.c
@@ -600,7 +600,7 @@ place_window_if_needed(MetaWindow     *window,
       info->fixed_directions = FIXED_DIRECTION_NONE;
     }
 
-  if (window->placed || did_placement)
+  if (window->reparents_pending == 0 && (window->placed || did_placement))
     {
       if (window->maximize_horizontally_after_placement ||
           window->maximize_vertically_after_placement)
-- 
GitLab


From 51e9fa8387892185f69081453a0039d017035780 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Fri, 7 Jul 2023 19:29:05 +0800
Subject: [PATCH 5/7] clutter/paint-volume: Don't over-enlarge 2D actorless
 paint volumes

A 2D actorless paint volume can't ever need `enlarge_for_effects` because
it has no depth. Clamping to the pixel boundary is sufficient in this case
and avoids extending volumes on the edge of the view into the next view.
Which then avoids unnecessary secondary monitor updates.

Paint volumes correctly become actorless where `clutter_actor_finish_layout`
calls `_clutter_paint_volume_transform_relative`.

Relates to: https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/6819

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3112>

(cherry picked from commit 2305efa990a43ec5a46c1fbb14a2d6b4613d8089)
---
 clutter/clutter/clutter-paint-volume.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/clutter/clutter/clutter-paint-volume.c b/clutter/clutter/clutter-paint-volume.c
index e2f273ef335..8986983d3d2 100644
--- a/clutter/clutter/clutter-paint-volume.c
+++ b/clutter/clutter/clutter-paint-volume.c
@@ -1061,8 +1061,8 @@ _clutter_paint_volume_get_stage_paint_box (const ClutterPaintVolume *pv,
 
   _clutter_paint_volume_get_bounding_box (&projected_pv, box);
 
-  if (pv->is_2d && pv->actor &&
-      clutter_actor_get_z_position (pv->actor) == 0)
+  if (pv->is_2d &&
+      (!pv->actor || clutter_actor_get_z_position (pv->actor) == 0))
     {
       /* If the volume/actor are perfectly 2D, take the bounding box as
        * good. We won't need to add any extra room for sub-pixel positioning
-- 
GitLab


From a95baeb48d39fc7ec6867504052c89cf0b12799e Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Fri, 10 Mar 2023 21:34:05 +0100
Subject: [PATCH 6/7] Revert "workspace: Focus the default window only if no
 window is focused"

This reverts commit 058981dc12b294b84040147eab247ac72da3011c.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2909>

(cherry picked from commit 3bbff537d9f95ba2f7fe328bcf3bd2c1d9de5900)
---
 src/core/workspace.c | 25 -------------------------
 1 file changed, 25 deletions(-)

diff --git a/src/core/workspace.c b/src/core/workspace.c
index a70791b4693..2a5c0c1ebe7 100644
--- a/src/core/workspace.c
+++ b/src/core/workspace.c
@@ -1339,40 +1339,15 @@ meta_workspace_get_name (MetaWorkspace *workspace)
   return meta_prefs_get_workspace_name (meta_workspace_index (workspace));
 }
 
-static MetaWindow *
-get_focused_workspace_window (MetaWorkspace *workspace)
-{
-  g_autoptr (GList) windows = NULL;
-  GList *l;
-
-  windows = meta_workspace_list_windows (workspace);
-
-  for (l = windows; l != NULL; l = l->next)
-    {
-      MetaWindow *window = l->data;
-
-      if (meta_window_has_focus (window))
-        return window;
-    }
-
-  return NULL;
-}
-
 void
 meta_workspace_focus_default_window (MetaWorkspace *workspace,
                                      MetaWindow    *not_this_one,
                                      guint32        timestamp)
 {
-  MetaWindow *focus;
-
   if (timestamp == META_CURRENT_TIME)
     meta_warning ("META_CURRENT_TIME used to choose focus window; "
                   "focus window may not be correct.");
 
-  focus = get_focused_workspace_window (workspace);
-  if (focus != NULL && focus != not_this_one)
-    return;
-
   if (meta_prefs_get_focus_mode () == G_DESKTOP_FOCUS_MODE_CLICK ||
       !workspace->display->mouse_mode)
     {
-- 
GitLab


From 41e41e2e2b937e28d438a5b2133e853d6c6203eb Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Fri, 10 Mar 2023 21:33:47 +0100
Subject: [PATCH 7/7] core/window: Change MRU behavior for windows on secondary
 output

Current behavior pushes a window which receives focus to the start of
the MRU list on every workspace it is on. By focusing a sticky window
the default focus on all other workspaces changes as well. This is fine
for sticky windows explicitly marked as sticky by the user but if a
window is on a secondary output and workspaces are only on the primary
output the behavior is unexpected. Instead we want the window to be the
default focus only on the current workspace but also keep those windows
in a relative MRU order to each other on all workspaces.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/2681
Fixes: 058981dc1 ("workspace: Focus the default window only if no window is focused")
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2909>

(cherry picked from commit 87bd574598539196ae102cfdb294957993519e74)
---
 src/core/window.c | 34 +++++++++++++++++++++++++++++-----
 1 file changed, 29 insertions(+), 5 deletions(-)

diff --git a/src/core/window.c b/src/core/window.c
index abe87e787a3..aa80a7cca92 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -4518,14 +4518,38 @@ meta_window_make_most_recent (MetaWindow *window)
   for (l = workspace_manager->workspaces; l != NULL; l = l->next)
     {
       MetaWorkspace *workspace = l->data;
-      GList *link;
+      GList *self, *link;
 
-      link = g_list_find (workspace->mru_list, window);
-      if (!link)
+      self = g_list_find (workspace->mru_list, window);
+      if (!self)
         continue;
 
-      workspace->mru_list = g_list_delete_link (workspace->mru_list, link);
-      workspace->mru_list = g_list_prepend (workspace->mru_list, window);
+      /*
+       * Move to the front of the MRU list if the window is on the
+       * active workspace or was explicitly made sticky
+       */
+      if (workspace == workspace_manager->active_workspace ||
+          window->on_all_workspaces_requested)
+        {
+          workspace->mru_list = g_list_delete_link (workspace->mru_list, self);
+          workspace->mru_list = g_list_prepend (workspace->mru_list, window);
+          continue;
+        }
+
+      /* Otherwise move it before other sticky windows */
+      for (link = workspace->mru_list; link; link = link->next)
+        {
+          MetaWindow *mru_window = link->data;
+
+          if (mru_window->workspace == NULL)
+            break;
+        }
+
+      if (link == self)
+        continue;
+
+      workspace->mru_list = g_list_delete_link (workspace->mru_list, self);
+      workspace->mru_list = g_list_insert_before (workspace->mru_list, link, window);
     }
 }
 
-- 
GitLab
